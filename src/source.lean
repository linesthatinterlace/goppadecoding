-- https://cr.yp.to/papers/goppadecoding-20220320.pdf
import tactic
import data.polynomial.basic
import linear_algebra.matrix.nondegenerate
import linear_algebra.vandermonde
import data.matrix.basic
import data.polynomial.derivative
import logic.equiv.basic
import linear_algebra.lagrange
/-import algebra.ring.basic
import ring_theory.ideal.basic
import algebra.group.units

import algebra.euclidean_domain
import data.matrix.basis
import data.matrix.notation-/
-- Section 2 (Polynomials)
/-
Much of this section is straightforwardly in mathlib. Imports are given (though
some may be redundant), and where there is a wrinkle to do with the way Lean
represents things, it's noted.
-/
section gdtwo
open polynomial matrix
open_locale big_operators classical polynomial matrix
-- 2.1 (Commutative rings)
/-
Provided by the comm_ring structure. Note that there is a theory of semirings,
not-necessarily-commutative rings, etc. also.

import algebra.ring.basic
-/

-- 2.2 Ring morphisms
/-
Provided by the ring_hom structure (which extends multiplicative and additive 
homomorphisms). This gives additive and multiplicative identity preservation,
and distribution over the operations. Preservation of additive inverse is given
by ring_hom.map_neg.

import algebra.ring.basic
-/

-- 2.3 Multiples
/-
This is simply about ideals and their generators. This is probably best given by
ideal.span (which defines the ideal which is generated by a ring). There are a
collection of span_singleton lemmas for the special case where the generating
set is a singleton (a principal ideal). There is a theorem of principal ideal
domains but this seems not necessary here.

import ring_theory.ideal.basic
-/

-- 2.4 Units
/-
The definition of a (multiplicative) unit is given by the is_unit predicate.
units M is the structure which contains the units of a monoid M in a bundled way
(that is, something of type units M contains the unit, its inverse, and proofs
that they form a left-sided and right-sided unit pair). units M is not a set - 
you cannot talk about a ∈ units M, but given some a : M (where we have [ring M]),
if you have a hypothesis of type is_unit a, that contains the u : units M whose
coercion is a, so you can extract it. 

import algebra.group.units
-/

-- 2.5 Fields
/-
Given by the field structure. The is_field predicate expresses that a ring is a
field; the is_field.to_field definition noncomputably takes a proof that a 
ring R is a field and gives the field structure resulting.

import algebra.field.basic

-/

-- 2.6 Vector space
/-
A vector space is a module over a field. Lean does not have a separate notion of
a vector space, and so the module structure (which corresponds to a semimodule
in regular maths - i.e. it can be defined over a semiring) is used for it.

There is a lot of subtlety here that is not relevant outside of the original 
algebraic context, and so other imports might be needed. Handle with care.

import algebra.module.basic
-/

-- 2.7 Standard n-dimensional vector space.
/-
A complicated issue because in full generality these structure can have
complicated indexing and so much is given in a high level of abstraction.
On top of that, finiteness can be a tricky issue when trying to do stuff
correctly. It might be that actually want you want is matrix.std_basis
or matrix.std_basis_matrix, as this could give you the matrix basis for the
special case of rows and columns. You need to think carefully about what is
meant here.

If you just want row vectors, incidentally, the ![a, b, ..., z] notation
introduced by data.fin.vec_notation will suffice, as these are things to which
matrices can be applied.

The following should give the required notation and the basis stuff. But here
be dragons if you aren't careful.

import data.matrix.basis
import data.matrix.notation
-/

-- 2.8 Linear maps
/-
The linear_map structure of algebra.module.linear_map is the abstract version of
this.

finrank_le_finrank_of_injective is the theorem that if a linear map between
two finite-dimensional spaces is injective, the dimension of the domain
is less than or equal to the dimension of the codomain. The converse implies
that when the domain has a greater dimension than the codomain, there is some
non-zero vector which maps to zero. One can also look at this using the
rank-nullity theorem, finrank_range_add_finrank_ker.

The theory of finite-dimensional spaces is obviously full of particular
theorems, and is covered by linear_algebra.finite_dimensional.

import algebra.module.linear_map
import linear_algebra.finite_dimensional
-/

-- 2.9 Polynomials
/-
Polynomials over a ring R are really just finitely-supported maps from R to
ℕ, along with the structure that retains the structure of R for addition and
scalar multiplication and defines products using convolution. This is an
additive monoid algebra, and so secretly this is just what a polynomial is
in Lean. However, data.polynomial.basic provides a good API and notation so that
we mostly don't have to worry about any of this.

Note that polynomials are not (currently) implemented in a computable way -
that is, the definition of polynomials is sufficiently abstracted that it
requires classical choice. This might change at some point (because it is
not ideal...)

import data.polynomial.basic

-/

-- 2.10 The ring-structure of polynomials
/-
As mentioned, the commutative ring structure on polynomials over a commutative
ring is virtually present by definition. polynomial.semiring is the core
instance - there are various other instances for generalisations or different
ways to view the structure.
-/

-- 2.11 The k-algebra structure of polynomials
/-
The polynomial.C map is the constant map from R to R[X]. This is the algebra 
map. The instance polynomial.algebra_of_algebra shows that A[X] is an R-algebra
when A is an R-algebra, which gives the special case when A = R, and API is
provided for working with this.

import data.polynomial.algebra_map
-/

-- 2.12 Units of k[x]
/-
The theorem polynomial.is_unit_iff characterises the units of R[X], where R is 
commutative domain, as the embedding of the units of R. When R is not a domain
but simply a commutative semiring, it is still true that a member of R is a unit
iff its embedding is (polynomial.is_unit_C). (Consider (2X + 1)*(2X + 1) when R
is Z/(4) - 2X + 1 is a unit without degree 0. The issue turns out to be that
deg(f*g) = deg f * deg g for non-zero f, g may not be true in the presence of
zero divisors.)

import data.polynomial.ring_division
-/

-- 2.13 The k-vector structure of polynomials
/-
We have polynomial.module as an instance, and it's definitionally equal to the
instance of module that arises from the instance of polynomials as an algebra
under the base ring - so from Lean's point of view these are the same.

import data.polynomial.basic
-/

-- 2.14 Powers of x
/-
monomial n a is the monomial a*X^n. We have sum_monomial_eq which tells us that
a polynomial is equal to the sum over its coefficients f_i of f_i*X^i (Lean
provides polynomial.sum to do this kind of summation: internally this is a 
finset.sum. This is as opposed to a finsum, which is the infinite sum over
finite non-zero values mentioned in the paper: for various reasons there are a
few different ways of doing finite sums but this is the way polynomial does 
things). We also have from this a way of doing induction on polynomials by 
proving an additive fact for monomials.

import data.polynomial.induction

-/

-- 2.15 Coefficients
/-
polynomial.coeff p n gives the nth coefficient of n in p, where n : ℕ. Extending
this to ℤ would not be too hard; what the appropriate decision in 4.1 would
be is yet to be answered.

import data.polynomial.basic
-/

-- 2.16 Degree
/-
We have both polynomial.degree and polynomial.nat_degree (which differ in how
they handle the zero polynomial). There are a good number of theorems for these.

import data.polynomial.basic
-/


-- 2.17 Monic polynomials
/-
There is a monic predicate.

import data.polynomial.degree.definitions
-/

-- 2.18 Evaluation
/-
polynomial.eval exists, though it is non-computable so you can prove theorems
about it but not actually evaluate computationally.

import data.polynomial.basic
-/
-- 2.19 Roots
/-
polynomial.roots gives a multiset of the polynomial's roots,
including multiplicity. It does not have a meaningful definition for the zero
polynomial!

import data.polynomial.basic
-/
-- 2.20 Vandermonde invertibility
/-
This derives from polynomial.card_roots, which is a version of it though not
in the equivalent form.

However, it is also true separately from polynomial theory.
-/

-- 2.21 Transposed Vandermonde inequality
/-
Easily proved.
-/

lemma det_vandermonde_ne_zero_of_injective {R : Type*} [comm_ring R] [is_domain R] {n : ℕ} (α : fin n → R) (h : function.injective α) : (vandermonde α).det ≠ 0 :=
begin
  rw det_vandermonde,
  simp only [finset.prod_ne_zero_iff, finset.mem_univ, forall_true_left, finset.mem_filter, true_and],
  intros _ _ hij contra,
  rw sub_eq_zero at contra,
  exact ne_of_lt hij (h contra.symm)
end

theorem matrix.vandermonde_invertibility {R : Type*} [comm_ring R] [is_domain R] {n : ℕ} {α : fin n → R} (h₁ : function.injective α) {f : fin n → R} (h₂ : ∀ j : fin n, ∑ i : fin n, f i * (α j ^ (i : ℕ)) = 0) : ∀ i, f i = 0 :=
begin
  suffices h : f = 0, rw h, exact λ i, rfl,
  apply eq_zero_of_mul_vec_eq_zero (det_vandermonde_ne_zero_of_injective _ h₁),
  refine funext (λ j, _),
  simp only [pi.zero_apply, ← h₂ j, mul_vec, dot_product, vandermonde_apply],
  refine congr_arg _ (funext (λ _, by ring)),
end

theorem matrix.vandermonde_invertibility_transposed {R : Type*} [comm_ring R] [is_domain R] {n : ℕ} {α : fin n → R} (h₁ : function.injective α) {f : fin n → R} (h₂ : ∀ i : fin n, ∑ j : fin n, f j * (α j ^ (i : ℕ)) = 0) : ∀ i, f i = 0 :=
begin
  suffices h : f = 0, rw h, exact λ i, rfl,
  have f_in_V_kernel : (vandermonde α).vec_mul f = 0, by { rw function.funext_iff, convert h₂ },
  apply eq_zero_of_vec_mul_eq_zero (det_vandermonde_ne_zero_of_injective α h₁) f_in_V_kernel
end

theorem polynomial.vandermonde_invertibility {R : Type*} [comm_ring R] [is_domain R] {n : ℕ} {α : fin n → R} {p : R[X]} (h₀ : degree p < n) (h₁ : function.injective α) (h₂ : ∀ j, p.is_root (α j)) : p = 0 :=
begin
  ext m, rw coeff_zero, 
  cases lt_or_le m n,
  { simp only [is_root.def, eval_eq_sum, ← sum_fin _ _ h₀, zero_mul, forall_const] at h₂,
    rw ← fin.coe_mk h, apply matrix.vandermonde_invertibility h₁ h₂ },
  { exact coeff_eq_zero_of_degree_lt (lt_of_lt_of_le h₀ (with_bot.coe_le_coe.mpr h)) },
end

theorem polynomial.vandermonde_invertibility_tranposed {R : Type*} [comm_ring R] [is_domain R] {n : ℕ} {α : fin n → R} {p : R[X]} (h₀ : degree p < n) (h₁ : function.injective α) (h₂ : ∀ i : fin n, ∑ j : fin n, p.coeff j * (α j ^ (i : ℕ)) = 0) : p = 0 :=
begin
  ext m, rw coeff_zero,
  cases lt_or_le m n,
  { rw ← fin.coe_mk h, apply matrix.vandermonde_invertibility_transposed h₁ h₂ },
  { exact coeff_eq_zero_of_degree_lt (lt_of_lt_of_le h₀ (with_bot.coe_le_coe.mpr h)) }
end

theorem polynomial.vandermonde_agreement {R : Type*} [comm_ring R] [is_domain R] {n : ℕ} {α : fin n → R} {p q : R[X]} (h₀ : (p - q).degree < n) (h₁ : function.injective α) (h₂ : ∀ j, p.eval (α j) = q.eval (α j)) : p = q :=
begin
  rw ← sub_eq_zero, apply polynomial.vandermonde_invertibility h₀ h₁,
  simp only [h₂, is_root.def, eval_sub, sub_self], exact λ _, rfl
end


noncomputable def finset.to_map_fin_card {α : Type*} (S : finset α) : fin (S.card) ↪ α :=
⟨ λ n, S.to_list.nth_le n (by {convert n.property, exact S.length_to_list }),
  λ _ _ hmn, by { rw [list.nodup.nth_le_inj_iff S.nodup_to_list] at hmn,
                simp only [hmn, fin.eq_iff_veq, fin.val_eq_coe]} ⟩

theorem finset.to_map_fin_card.mem {α : Type*} (S : finset α) (i : fin (S.card)) : S.to_map_fin_card i ∈ S :=
begin
  rw [finset.to_map_fin_card, ← S.mem_to_list],
  apply list.nth_le_mem
end

theorem polynomial.vandermonde_invertibility' {R : Type*} [comm_ring R] [is_domain R] {S : finset R} {p : R[X]} (h₀ : degree p < S.card) (h₂ : ∀ x ∈ S, p.is_root x) : p = 0 :=
begin
  ext m, rw coeff_zero,
  cases lt_or_le m (S.card),
  { simp only [is_root.def, eval_eq_sum, ← sum_fin _ _ h₀, zero_mul, forall_const] at h₂,
    rw ← fin.coe_mk h,
    apply matrix.vandermonde_invertibility (function.embedding.injective _) (λ _, h₂ _ (finset.to_map_fin_card.mem S _)),
  },
  { exact coeff_eq_zero_of_degree_lt (lt_of_lt_of_le h₀ (with_bot.coe_le_coe.mpr h)) }
end

theorem polynomial.vandermonde_invertibility_tranposed' {R : Type*} [comm_ring R] [is_domain R] {S : finset R} {p : R[X]} (h₀ : degree p < S.card) (h₂ : ∀ i : fin (S.card), ∑ j : fin (S.card), p.coeff j * (S.to_map_fin_card j) ^ (i : ℕ) = 0) : p = 0 :=
begin
  ext m, rw coeff_zero,
  cases lt_or_le m (S.card),
  { rw ← fin.coe_mk h, apply matrix.vandermonde_invertibility_transposed (function.embedding.injective _) h₂ },
  { exact coeff_eq_zero_of_degree_lt (lt_of_lt_of_le h₀ (with_bot.coe_le_coe.mpr h)) }
end

theorem polynomial.vandermonde_agreement' {R : Type*} [comm_ring R] [is_domain R] {S : finset R} {p q : R[X]} (h₀ : degree (p - q) < S.card)  (h₂ : ∀ x ∈ S, p.eval x = q.eval x) : p = q :=
begin
  rw ← sub_eq_zero, apply polynomial.vandermonde_invertibility' (by assumption),
  simpa only [is_root.def, eval_sub, sub_eq_zero]
end


-- 2.22 Derivatives
/-
polynomial.derivative is the formal derivative of a polynomial. The product 
rule is proven for it. Bernoulli's rule is not proven for it, but this shouldn't
be too difficult.

import data.polynomial.derivative
-/

theorem bernoulli_rule {R : Type*} [comm_ring R]  {p q : R[X]} {x : R} (h : p.is_root x) : (p*q).derivative.eval x = p.derivative.eval x * q.eval x :=
begin
  rw is_root.def at h,
  simp only [is_root.def, h, derivative_mul, eval_add, eval_mul, zero_mul, add_zero]
end 

-- 2.23 Quotients and remainders
/-
There is a notion of polynomial division and modulo, but also polynomial
is a Euclidean domain which gives the q/r decomposition.
-/
-- 2.24 Unique Factorisation
/-
We have an instance of unique_factorization_monoid for polynomial, and it follows
from the Euclidean domain stuff.

-/
-- 2.25 Greatest common divisors
/-
Follows from Euclidean domain.
-/

-- 2.26 Squarefreeness
/-
polynomial.separable.squarefree precisely gives that a polynomial is squarefree
if it is separable - which is exactly that it is coprime with its formal derivative.

import field_theory.separable
-/

end gdtwo

/-

namespace polynomial

universes u y v

variables {R : Type u} [comm_semiring R] {ι : Type y}

open_locale polynomial classical big_operators

theorem derivative_prod' {s : finset ι} {f : ι → R[X]} :
  derivative (∏ b in s, f b) = ∑ b in s, (∏ a in (s.erase b), f a) * (f b).derivative := derivative_prod

end polynomial
-/

section gdthree
open_locale polynomial classical big_operators



noncomputable theory

open polynomial finset

universes u v

def nodal {F : Type u} [field F] (s : finset F) : F[X] := ∏ y in s, (X - C y)

lemma nodal_eq_remove {F : Type u} [field F] {s : finset F} {x : F} (hx : x ∈ s) : nodal s = (X - C x) * (∏ y in s.erase x, (X - C y)) := by {rw mul_prod_erase _ _ hx, refl}

lemma nodal_derive_eval_node_eq {F : Type u} [field F] {s : finset F} {x : F} (hx : x ∈ s) : eval x (nodal s).derivative = ∏ y in (s.erase x), (x - y) := 
begin
  rw [nodal_eq_remove hx, bernoulli_rule (polynomial.root_X_sub_C.mpr rfl)],
  simp_rw [eval_prod, derivative_sub, derivative_X, derivative_C, sub_zero, eval_one, one_mul, eval_sub, eval_X, eval_C]
end

lemma nodal_div_eq {F : Type u} [field F] {s : finset F} {x : F} (hx : x ∈ s) :
nodal s / (X - C x) = (∏ y in s.erase x, (X - C y)) := 
begin
  rw [nodal_eq_remove hx, euclidean_domain.mul_div_cancel_left],
  apply X_sub_C_ne_zero,
end

lemma lagrange.basis_eq_nodal_div_eval_deriv_mul_linear {F : Type u} [field F] {s : finset F} {x : F} (hx : x ∈ s) : lagrange.basis s x = C (eval x (nodal s).derivative)⁻¹ * (nodal s / (X - C x))  :=
begin
  unfold lagrange.basis,
  rw [nodal_div_eq hx, nodal_derive_eval_node_eq hx, prod_mul_distrib, ← prod_inv_distrib', map_prod],
end

lemma interpolate_eq_derivative_interpolate {F : Type u} [field F] (s : finset F) (f : F → F) : lagrange.interpolate s f = ∑ x in s, C (f x * (eval x (nodal s).derivative)⁻¹) * (nodal s / (X - C x)) :=
begin
  apply sum_congr rfl, intros _ hx,
  rw [C.map_mul, lagrange.basis_eq_nodal_div_eval_deriv_mul_linear hx, mul_assoc]
end

end gdthree